
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">connect-go-example/api/check/v1/check.pb.go (0.0%)</option>
				
				<option value="file1">connect-go-example/api/check/v1/checkv1connect/check.connect.go (0.0%)</option>
				
				<option value="file2">connect-go-example/api/greet/v1/greet.pb.go (0.0%)</option>
				
				<option value="file3">connect-go-example/api/greet/v1/greetv1connect/greet.connect.go (0.0%)</option>
				
				<option value="file4">connect-go-example/cmd/server/main.go (0.0%)</option>
				
				<option value="file5">connect-go-example/internal/biz/check.go (100.0%)</option>
				
				<option value="file6">connect-go-example/internal/biz/user.go (63.8%)</option>
				
				<option value="file7">connect-go-example/internal/conf/v1/conf.pb.go (0.0%)</option>
				
				<option value="file8">connect-go-example/internal/data/check.go (14.3%)</option>
				
				<option value="file9">connect-go-example/internal/data/data.go (2.6%)</option>
				
				<option value="file10">connect-go-example/internal/data/models/db.go (50.0%)</option>
				
				<option value="file11">connect-go-example/internal/data/models/query.sql.go (66.7%)</option>
				
				<option value="file12">connect-go-example/internal/data/user.go (0.0%)</option>
				
				<option value="file13">connect-go-example/internal/pkg/config/config.go (54.5%)</option>
				
				<option value="file14">connect-go-example/internal/pkg/log/log.go (42.9%)</option>
				
				<option value="file15">connect-go-example/internal/pkg/otel/otel.go (0.0%)</option>
				
				<option value="file16">connect-go-example/internal/pkg/registry/consul.go (0.0%)</option>
				
				<option value="file17">connect-go-example/internal/server/middleware.go (90.6%)</option>
				
				<option value="file18">connect-go-example/internal/server/server.go (72.2%)</option>
				
				<option value="file19">connect-go-example/internal/service/check.go (100.0%)</option>
				
				<option value="file20">connect-go-example/internal/service/user.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.10
//         protoc        (unknown)
// source: api/check/v1/check.proto

package checkv1

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ReadyCheckReq struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReadyCheckReq) Reset() <span class="cov0" title="0">{
        *x = ReadyCheckReq{}
        mi := &amp;file_api_check_v1_check_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReadyCheckReq) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReadyCheckReq) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReadyCheckReq) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_check_v1_check_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReadyCheckReq.ProtoReflect.Descriptor instead.
func (*ReadyCheckReq) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_check_v1_check_proto_rawDescGZIP(), []int{0}
}</span>

type ReadyCheckReply struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Status        string                 `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
        Details       map[string]string      `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ReadyCheckReply) Reset() <span class="cov0" title="0">{
        *x = ReadyCheckReply{}
        mi := &amp;file_api_check_v1_check_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ReadyCheckReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ReadyCheckReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ReadyCheckReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_check_v1_check_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ReadyCheckReply.ProtoReflect.Descriptor instead.
func (*ReadyCheckReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_check_v1_check_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ReadyCheckReply) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ReadyCheckReply) GetDetails() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_api_check_v1_check_proto protoreflect.FileDescriptor

const file_api_check_v1_check_proto_rawDesc = "" +
        "\n" +
        "\x18api/check/v1/check.proto\x12\bcheck.v1\"\x0f\n" +
        "\rReadyCheckReq\"\xa7\x01\n" +
        "\x0fReadyCheckReply\x12\x16\n" +
        "\x06status\x18\x01 \x01(\tR\x06status\x12@\n" +
        "\adetails\x18\x02 \x03(\v2&amp;.check.v1.ReadyCheckReply.DetailsEntryR\adetails\x1a:\n" +
        "\fDetailsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x012M\n" +
        "\fCheckService\x12=\n" +
        "\x05Ready\x12\x17.check.v1.ReadyCheckReq\x1a\x19.check.v1.ReadyCheckReply\"\x00B\x84\x01\n" +
        "\fcom.check.v1B\n" +
        "CheckProtoP\x01Z'connect-go-example/api/check/v1;checkv1\xa2\x02\x03CXX\xaa\x02\bCheck.V1\xca\x02\bCheck\\V1\xe2\x02\x14Check\\V1\\GPBMetadata\xea\x02\tCheck::V1b\x06proto3"

var (
        file_api_check_v1_check_proto_rawDescOnce sync.Once
        file_api_check_v1_check_proto_rawDescData []byte
)

func file_api_check_v1_check_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_check_v1_check_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_check_v1_check_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_check_v1_check_proto_rawDesc), len(file_api_check_v1_check_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_check_v1_check_proto_rawDescData</span>
}

var (
        file_api_check_v1_check_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
        file_api_check_v1_check_proto_goTypes  = []any{
                (*ReadyCheckReq)(nil),   // 0: check.v1.ReadyCheckReq
                (*ReadyCheckReply)(nil), // 1: check.v1.ReadyCheckReply
                nil,                     // 2: check.v1.ReadyCheckReply.DetailsEntry
        }
)

var file_api_check_v1_check_proto_depIdxs = []int32{
        2, // 0: check.v1.ReadyCheckReply.details:type_name -&gt; check.v1.ReadyCheckReply.DetailsEntry
        0, // 1: check.v1.CheckService.Ready:input_type -&gt; check.v1.ReadyCheckReq
        1, // 2: check.v1.CheckService.Ready:output_type -&gt; check.v1.ReadyCheckReply
        2, // [2:3] is the sub-list for method output_type
        1, // [1:2] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_check_v1_check_proto_init() }</span>
func file_api_check_v1_check_proto_init() <span class="cov0" title="0">{
        if File_api_check_v1_check_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_check_v1_check_proto_rawDesc), len(file_api_check_v1_check_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_check_v1_check_proto_goTypes,
                DependencyIndexes: file_api_check_v1_check_proto_depIdxs,
                MessageInfos:      file_api_check_v1_check_proto_msgTypes,
        }.Build()
        File_api_check_v1_check_proto = out.File
        file_api_check_v1_check_proto_goTypes = nil
        file_api_check_v1_check_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: api/check/v1/check.proto

package checkv1connect

import (
        context "context"
        errors "errors"
        http "net/http"
        strings "strings"

        v1 "connect-go-example/api/check/v1"
        connect "connectrpc.com/connect"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
        // CheckServiceName is the fully-qualified name of the CheckService service.
        CheckServiceName = "check.v1.CheckService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
        // CheckServiceReadyProcedure is the fully-qualified name of the CheckService's Ready RPC.
        CheckServiceReadyProcedure = "/check.v1.CheckService/Ready"
)

// CheckServiceClient is a client for the check.v1.CheckService service.
type CheckServiceClient interface {
        Ready(context.Context, *connect.Request[v1.ReadyCheckReq]) (*connect.Response[v1.ReadyCheckReply], error)
}

// NewCheckServiceClient constructs a client for the check.v1.CheckService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewCheckServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) CheckServiceClient <span class="cov0" title="0">{
        baseURL = strings.TrimRight(baseURL, "/")
        checkServiceMethods := v1.File_api_check_v1_check_proto.Services().ByName("CheckService").Methods()
        return &amp;checkServiceClient{
                ready: connect.NewClient[v1.ReadyCheckReq, v1.ReadyCheckReply](
                        httpClient,
                        baseURL+CheckServiceReadyProcedure,
                        connect.WithSchema(checkServiceMethods.ByName("Ready")),
                        connect.WithClientOptions(opts...),
                ),
        }
}</span>

// checkServiceClient implements CheckServiceClient.
type checkServiceClient struct {
        ready *connect.Client[v1.ReadyCheckReq, v1.ReadyCheckReply]
}

// Ready calls check.v1.CheckService.Ready.
func (c *checkServiceClient) Ready(ctx context.Context, req *connect.Request[v1.ReadyCheckReq]) (*connect.Response[v1.ReadyCheckReply], error) <span class="cov0" title="0">{
        return c.ready.CallUnary(ctx, req)
}</span>

// CheckServiceHandler is an implementation of the check.v1.CheckService service.
type CheckServiceHandler interface {
        Ready(context.Context, *connect.Request[v1.ReadyCheckReq]) (*connect.Response[v1.ReadyCheckReply], error)
}

// NewCheckServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewCheckServiceHandler(svc CheckServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) <span class="cov0" title="0">{
        checkServiceMethods := v1.File_api_check_v1_check_proto.Services().ByName("CheckService").Methods()
        checkServiceReadyHandler := connect.NewUnaryHandler(
                CheckServiceReadyProcedure,
                svc.Ready,
                connect.WithSchema(checkServiceMethods.ByName("Ready")),
                connect.WithHandlerOptions(opts...),
        )
        return "/check.v1.CheckService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                switch r.URL.Path </span>{
                case CheckServiceReadyProcedure:<span class="cov0" title="0">
                        checkServiceReadyHandler.ServeHTTP(w, r)</span>
                default:<span class="cov0" title="0">
                        http.NotFound(w, r)</span>
                }
        })
}

// UnimplementedCheckServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedCheckServiceHandler struct{}

func (UnimplementedCheckServiceHandler) Ready(context.Context, *connect.Request[v1.ReadyCheckReq]) (*connect.Response[v1.ReadyCheckReply], error) <span class="cov0" title="0">{
        return nil, connect.NewError(connect.CodeUnimplemented, errors.New("check.v1.CheckService.Ready is not implemented"))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.10
//         protoc        (unknown)
// source: api/greet/v1/greet.proto

package greetv1

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RegisterRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        PasswordHash  string                 `protobuf:"bytes,2,opt,name=password_hash,json=passwordHash,proto3" json:"password_hash,omitempty"`
        Email         string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Salt          string                 `protobuf:"bytes,4,opt,name=salt,proto3" json:"salt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_greet_v1_greet_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPasswordHash() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PasswordHash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetSalt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Salt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_greet_v1_greet_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterResponse) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AuthChallengeRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AuthChallengeRequest) Reset() <span class="cov0" title="0">{
        *x = AuthChallengeRequest{}
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AuthChallengeRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthChallengeRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthChallengeRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthChallengeRequest.ProtoReflect.Descriptor instead.
func (*AuthChallengeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_greet_v1_greet_proto_rawDescGZIP(), []int{2}
}</span>

func (x *AuthChallengeRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AuthChallengeResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Challenge     string                 `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
        Salt          string                 `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AuthChallengeResponse) Reset() <span class="cov0" title="0">{
        *x = AuthChallengeResponse{}
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AuthChallengeResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthChallengeResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthChallengeResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthChallengeResponse.ProtoReflect.Descriptor instead.
func (*AuthChallengeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_greet_v1_greet_proto_rawDescGZIP(), []int{3}
}</span>

func (x *AuthChallengeResponse) GetChallenge() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Challenge
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthChallengeResponse) GetSalt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Salt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SubmitAuthRequest struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Username          string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        HashedCredential  string                 `protobuf:"bytes,2,opt,name=hashed_credential,json=hashedCredential,proto3" json:"hashed_credential,omitempty"`    // 客户端使用密码 + salt 哈希后的凭证
        AuthRequestId     string                 `protobuf:"bytes,3,opt,name=auth_request_id,json=authRequestId,proto3" json:"auth_request_id,omitempty"`           // 链路追踪
        ChallengeResponse string                 `protobuf:"bytes,4,opt,name=challenge_response,json=challengeResponse,proto3" json:"challenge_response,omitempty"` // 客户端对挑战的响应
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *SubmitAuthRequest) Reset() <span class="cov0" title="0">{
        *x = SubmitAuthRequest{}
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SubmitAuthRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubmitAuthRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubmitAuthRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubmitAuthRequest.ProtoReflect.Descriptor instead.
func (*SubmitAuthRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_greet_v1_greet_proto_rawDescGZIP(), []int{4}
}</span>

func (x *SubmitAuthRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubmitAuthRequest) GetHashedCredential() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HashedCredential
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubmitAuthRequest) GetAuthRequestId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthRequestId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubmitAuthRequest) GetChallengeResponse() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ChallengeResponse
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SubmitAuthResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          string                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
        State         string                 `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
        AuthToken     string                 `protobuf:"bytes,3,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"` // jwt令牌
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SubmitAuthResponse) Reset() <span class="cov0" title="0">{
        *x = SubmitAuthResponse{}
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SubmitAuthResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubmitAuthResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubmitAuthResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_greet_v1_greet_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubmitAuthResponse.ProtoReflect.Descriptor instead.
func (*SubmitAuthResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_greet_v1_greet_proto_rawDescGZIP(), []int{5}
}</span>

func (x *SubmitAuthResponse) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubmitAuthResponse) GetState() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.State
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubmitAuthResponse) GetAuthToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_api_greet_v1_greet_proto protoreflect.FileDescriptor

const file_api_greet_v1_greet_proto_rawDesc = "" +
        "\n" +
        "\x18api/greet/v1/greet.proto\x12\bgreet.v1\"|\n" +
        "\x0fRegisterRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\x12#\n" +
        "\rpassword_hash\x18\x02 \x01(\tR\fpasswordHash\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email\x12\x12\n" +
        "\x04salt\x18\x04 \x01(\tR\x04salt\"+\n" +
        "\x10RegisterResponse\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\"2\n" +
        "\x14AuthChallengeRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\"I\n" +
        "\x15AuthChallengeResponse\x12\x1c\n" +
        "\tchallenge\x18\x01 \x01(\tR\tchallenge\x12\x12\n" +
        "\x04salt\x18\x02 \x01(\tR\x04salt\"\xb3\x01\n" +
        "\x11SubmitAuthRequest\x12\x1a\n" +
        "\busername\x18\x01 \x01(\tR\busername\x12+\n" +
        "\x11hashed_credential\x18\x02 \x01(\tR\x10hashedCredential\x12&amp;\n" +
        "\x0fauth_request_id\x18\x03 \x01(\tR\rauthRequestId\x12-\n" +
        "\x12challenge_response\x18\x04 \x01(\tR\x11challengeResponse\"]\n" +
        "\x12SubmitAuthResponse\x12\x12\n" +
        "\x04code\x18\x01 \x01(\tR\x04code\x12\x14\n" +
        "\x05state\x18\x02 \x01(\tR\x05state\x12\x1d\n" +
        "\n" +
        "auth_token\x18\x03 \x01(\tR\tauthToken2\xf5\x01\n" +
        "\fGreetService\x12C\n" +
        "\bRegister\x12\x19.greet.v1.RegisterRequest\x1a\x1a.greet.v1.RegisterResponse\"\x00\x12U\n" +
        "\x10GetAuthChallenge\x12\x1e.greet.v1.AuthChallengeRequest\x1a\x1f.greet.v1.AuthChallengeResponse\"\x00\x12I\n" +
        "\n" +
        "SubmitAuth\x12\x1b.greet.v1.SubmitAuthRequest\x1a\x1c.greet.v1.SubmitAuthResponse\"\x00B\x84\x01\n" +
        "\fcom.greet.v1B\n" +
        "GreetProtoP\x01Z'connect-go-example/api/greet/v1;greetv1\xa2\x02\x03GXX\xaa\x02\bGreet.V1\xca\x02\bGreet\\V1\xe2\x02\x14Greet\\V1\\GPBMetadata\xea\x02\tGreet::V1b\x06proto3"

var (
        file_api_greet_v1_greet_proto_rawDescOnce sync.Once
        file_api_greet_v1_greet_proto_rawDescData []byte
)

func file_api_greet_v1_greet_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_greet_v1_greet_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_greet_v1_greet_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_greet_v1_greet_proto_rawDesc), len(file_api_greet_v1_greet_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_greet_v1_greet_proto_rawDescData</span>
}

var (
        file_api_greet_v1_greet_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
        file_api_greet_v1_greet_proto_goTypes  = []any{
                (*RegisterRequest)(nil),       // 0: greet.v1.RegisterRequest
                (*RegisterResponse)(nil),      // 1: greet.v1.RegisterResponse
                (*AuthChallengeRequest)(nil),  // 2: greet.v1.AuthChallengeRequest
                (*AuthChallengeResponse)(nil), // 3: greet.v1.AuthChallengeResponse
                (*SubmitAuthRequest)(nil),     // 4: greet.v1.SubmitAuthRequest
                (*SubmitAuthResponse)(nil),    // 5: greet.v1.SubmitAuthResponse
        }
)

var file_api_greet_v1_greet_proto_depIdxs = []int32{
        0, // 0: greet.v1.GreetService.Register:input_type -&gt; greet.v1.RegisterRequest
        2, // 1: greet.v1.GreetService.GetAuthChallenge:input_type -&gt; greet.v1.AuthChallengeRequest
        4, // 2: greet.v1.GreetService.SubmitAuth:input_type -&gt; greet.v1.SubmitAuthRequest
        1, // 3: greet.v1.GreetService.Register:output_type -&gt; greet.v1.RegisterResponse
        3, // 4: greet.v1.GreetService.GetAuthChallenge:output_type -&gt; greet.v1.AuthChallengeResponse
        5, // 5: greet.v1.GreetService.SubmitAuth:output_type -&gt; greet.v1.SubmitAuthResponse
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_greet_v1_greet_proto_init() }</span>
func file_api_greet_v1_greet_proto_init() <span class="cov0" title="0">{
        if File_api_greet_v1_greet_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_greet_v1_greet_proto_rawDesc), len(file_api_greet_v1_greet_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_greet_v1_greet_proto_goTypes,
                DependencyIndexes: file_api_greet_v1_greet_proto_depIdxs,
                MessageInfos:      file_api_greet_v1_greet_proto_msgTypes,
        }.Build()
        File_api_greet_v1_greet_proto = out.File
        file_api_greet_v1_greet_proto_goTypes = nil
        file_api_greet_v1_greet_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: api/greet/v1/greet.proto

package greetv1connect

import (
        context "context"
        errors "errors"
        http "net/http"
        strings "strings"

        v1 "connect-go-example/api/greet/v1"
        connect "connectrpc.com/connect"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
        // GreetServiceName is the fully-qualified name of the GreetService service.
        GreetServiceName = "greet.v1.GreetService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
        // GreetServiceRegisterProcedure is the fully-qualified name of the GreetService's Register RPC.
        GreetServiceRegisterProcedure = "/greet.v1.GreetService/Register"
        // GreetServiceGetAuthChallengeProcedure is the fully-qualified name of the GreetService's
        // GetAuthChallenge RPC.
        GreetServiceGetAuthChallengeProcedure = "/greet.v1.GreetService/GetAuthChallenge"
        // GreetServiceSubmitAuthProcedure is the fully-qualified name of the GreetService's SubmitAuth RPC.
        GreetServiceSubmitAuthProcedure = "/greet.v1.GreetService/SubmitAuth"
)

// GreetServiceClient is a client for the greet.v1.GreetService service.
type GreetServiceClient interface {
        Register(context.Context, *connect.Request[v1.RegisterRequest]) (*connect.Response[v1.RegisterResponse], error)
        GetAuthChallenge(context.Context, *connect.Request[v1.AuthChallengeRequest]) (*connect.Response[v1.AuthChallengeResponse], error)
        SubmitAuth(context.Context, *connect.Request[v1.SubmitAuthRequest]) (*connect.Response[v1.SubmitAuthResponse], error)
}

// NewGreetServiceClient constructs a client for the greet.v1.GreetService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewGreetServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) GreetServiceClient <span class="cov0" title="0">{
        baseURL = strings.TrimRight(baseURL, "/")
        greetServiceMethods := v1.File_api_greet_v1_greet_proto.Services().ByName("GreetService").Methods()
        return &amp;greetServiceClient{
                register: connect.NewClient[v1.RegisterRequest, v1.RegisterResponse](
                        httpClient,
                        baseURL+GreetServiceRegisterProcedure,
                        connect.WithSchema(greetServiceMethods.ByName("Register")),
                        connect.WithClientOptions(opts...),
                ),
                getAuthChallenge: connect.NewClient[v1.AuthChallengeRequest, v1.AuthChallengeResponse](
                        httpClient,
                        baseURL+GreetServiceGetAuthChallengeProcedure,
                        connect.WithSchema(greetServiceMethods.ByName("GetAuthChallenge")),
                        connect.WithClientOptions(opts...),
                ),
                submitAuth: connect.NewClient[v1.SubmitAuthRequest, v1.SubmitAuthResponse](
                        httpClient,
                        baseURL+GreetServiceSubmitAuthProcedure,
                        connect.WithSchema(greetServiceMethods.ByName("SubmitAuth")),
                        connect.WithClientOptions(opts...),
                ),
        }
}</span>

// greetServiceClient implements GreetServiceClient.
type greetServiceClient struct {
        register         *connect.Client[v1.RegisterRequest, v1.RegisterResponse]
        getAuthChallenge *connect.Client[v1.AuthChallengeRequest, v1.AuthChallengeResponse]
        submitAuth       *connect.Client[v1.SubmitAuthRequest, v1.SubmitAuthResponse]
}

// Register calls greet.v1.GreetService.Register.
func (c *greetServiceClient) Register(ctx context.Context, req *connect.Request[v1.RegisterRequest]) (*connect.Response[v1.RegisterResponse], error) <span class="cov0" title="0">{
        return c.register.CallUnary(ctx, req)
}</span>

// GetAuthChallenge calls greet.v1.GreetService.GetAuthChallenge.
func (c *greetServiceClient) GetAuthChallenge(ctx context.Context, req *connect.Request[v1.AuthChallengeRequest]) (*connect.Response[v1.AuthChallengeResponse], error) <span class="cov0" title="0">{
        return c.getAuthChallenge.CallUnary(ctx, req)
}</span>

// SubmitAuth calls greet.v1.GreetService.SubmitAuth.
func (c *greetServiceClient) SubmitAuth(ctx context.Context, req *connect.Request[v1.SubmitAuthRequest]) (*connect.Response[v1.SubmitAuthResponse], error) <span class="cov0" title="0">{
        return c.submitAuth.CallUnary(ctx, req)
}</span>

// GreetServiceHandler is an implementation of the greet.v1.GreetService service.
type GreetServiceHandler interface {
        Register(context.Context, *connect.Request[v1.RegisterRequest]) (*connect.Response[v1.RegisterResponse], error)
        GetAuthChallenge(context.Context, *connect.Request[v1.AuthChallengeRequest]) (*connect.Response[v1.AuthChallengeResponse], error)
        SubmitAuth(context.Context, *connect.Request[v1.SubmitAuthRequest]) (*connect.Response[v1.SubmitAuthResponse], error)
}

// NewGreetServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewGreetServiceHandler(svc GreetServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) <span class="cov0" title="0">{
        greetServiceMethods := v1.File_api_greet_v1_greet_proto.Services().ByName("GreetService").Methods()
        greetServiceRegisterHandler := connect.NewUnaryHandler(
                GreetServiceRegisterProcedure,
                svc.Register,
                connect.WithSchema(greetServiceMethods.ByName("Register")),
                connect.WithHandlerOptions(opts...),
        )
        greetServiceGetAuthChallengeHandler := connect.NewUnaryHandler(
                GreetServiceGetAuthChallengeProcedure,
                svc.GetAuthChallenge,
                connect.WithSchema(greetServiceMethods.ByName("GetAuthChallenge")),
                connect.WithHandlerOptions(opts...),
        )
        greetServiceSubmitAuthHandler := connect.NewUnaryHandler(
                GreetServiceSubmitAuthProcedure,
                svc.SubmitAuth,
                connect.WithSchema(greetServiceMethods.ByName("SubmitAuth")),
                connect.WithHandlerOptions(opts...),
        )
        return "/greet.v1.GreetService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                switch r.URL.Path </span>{
                case GreetServiceRegisterProcedure:<span class="cov0" title="0">
                        greetServiceRegisterHandler.ServeHTTP(w, r)</span>
                case GreetServiceGetAuthChallengeProcedure:<span class="cov0" title="0">
                        greetServiceGetAuthChallengeHandler.ServeHTTP(w, r)</span>
                case GreetServiceSubmitAuthProcedure:<span class="cov0" title="0">
                        greetServiceSubmitAuthHandler.ServeHTTP(w, r)</span>
                default:<span class="cov0" title="0">
                        http.NotFound(w, r)</span>
                }
        })
}

// UnimplementedGreetServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedGreetServiceHandler struct{}

func (UnimplementedGreetServiceHandler) Register(context.Context, *connect.Request[v1.RegisterRequest]) (*connect.Response[v1.RegisterResponse], error) <span class="cov0" title="0">{
        return nil, connect.NewError(connect.CodeUnimplemented, errors.New("greet.v1.GreetService.Register is not implemented"))
}</span>

func (UnimplementedGreetServiceHandler) GetAuthChallenge(context.Context, *connect.Request[v1.AuthChallengeRequest]) (*connect.Response[v1.AuthChallengeResponse], error) <span class="cov0" title="0">{
        return nil, connect.NewError(connect.CodeUnimplemented, errors.New("greet.v1.GreetService.GetAuthChallenge is not implemented"))
}</span>

func (UnimplementedGreetServiceHandler) SubmitAuth(context.Context, *connect.Request[v1.SubmitAuthRequest]) (*connect.Response[v1.SubmitAuthResponse], error) <span class="cov0" title="0">{
        return nil, connect.NewError(connect.CodeUnimplemented, errors.New("greet.v1.GreetService.SubmitAuth is not implemented"))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "errors"
        "flag"
        "log"
        "net/http"
        "os"

        "connect-go-example/internal/biz"
        confv1 "connect-go-example/internal/conf/v1"
        "connect-go-example/internal/data"
        "connect-go-example/internal/pkg/config"
        logger "connect-go-example/internal/pkg/log"
        "connect-go-example/internal/pkg/otel"
        "connect-go-example/internal/pkg/registry"
        "connect-go-example/internal/server"
        "connect-go-example/internal/service"

        "go.uber.org/fx"
        "go.uber.org/zap"
)

var serviceName = "connect-example-go"

type ServiceName string

func main() <span class="cov0" title="0">{
        flag.Parse()

        fxApp := NewApp()

        // 启动应用
        if err := fxApp.Start(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to start app: %v\n", err)
                os.Exit(1)
        }</span>

        // 等待中断信号
        <span class="cov0" title="0">&lt;-fxApp.Done()

        // 优雅关闭
        if err := fxApp.Stop(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to stop app gracefully: %v\n", err)
                os.Exit(1)
        }</span>
}

// NewApp 创建并配置 FX 应用
func NewApp() *fx.App <span class="cov0" title="0">{
        return fx.New(
                // 提供基础模块
                config.Module,
                logger.Module,
                registry.Module,

                // 注入业务模块（按依赖顺序）
                data.Module,
                biz.Module,
                service.Module,
                server.MiddlewareModule, // 中间件模块需要在服务器模块之前
                server.Module,

                // 传递全局变量
                fx.Supply(serviceName),

                // 配置验证和初始化
                fx.Invoke(
                        // 验证配置完整性
                        func(conf *confv1.Bootstrap) error </span><span class="cov0" title="0">{
                                return config.ValidateConfig(conf)
                        }</span>,

                        // 注册应用到注册中心
                        func(_ *registry.ConsulRegistry) {<span class="cov0" title="0">}</span>,

                        // 初始化并启动核心应用逻辑
                        func(lc fx.Lifecycle, conf *confv1.Bootstrap, logger *zap.Logger, srv *http.Server) <span class="cov0" title="0">{
                                // 初始化 Otel
                                otelShutdown, err := otel.SetupOTelSDK(context.Background(), conf.Trace, logger)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Fatal("Failed to setup OTel SDK", zap.Error(err))
                                }</span>

                                // 使用生命周期钩子
                                <span class="cov0" title="0">lc.Append(fx.Hook{
                                        OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                                                logger.Info("Starting HTTP server", zap.String("addr", srv.Addr))
                                                go func() </span><span class="cov0" title="0">{
                                                        if err := srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                                                logger.Fatal("Failed to start HTTP server", zap.Error(err))
                                                        }</span>
                                                }()
                                                <span class="cov0" title="0">return nil</span>
                                        },
                                        OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                                                logger.Info("Stopping HTTP server...")
                                                // 优雅关闭服务器
                                                if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                                        logger.Error("Failed to shutdown server gracefully", zap.Error(err))
                                                }</span>
                                                // 关闭 Otel（如果已启用）
                                                <span class="cov0" title="0">if otelShutdown != nil </span><span class="cov0" title="0">{
                                                        if err := otelShutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                                                logger.Error("Failed to shutdown OTel", zap.Error(err))
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">return nil</span>
                                        },
                                })
                        },
                ),
        )
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package biz

import (
        "context"

        "connect-go-example/internal/biz/model"
        "connect-go-example/internal/data"
)

type CheckUseCase struct {
        repo data.CheckRepo
}

func NewCheckUseCase(repo data.CheckRepo) (model.CheckUseCase, error) <span class="cov8" title="1">{
        return &amp;CheckUseCase{
                repo: repo,
        }, nil
}</span>

func (c CheckUseCase) Ready(ctx context.Context, req model.HealthCheckReq) (model.HealthCheckReply, error) <span class="cov8" title="1">{
        reply, err := c.repo.Ready(ctx, req)
        if err != nil </span><span class="cov8" title="1">{
                return model.HealthCheckReply{}, err
        }</span>
        <span class="cov8" title="1">return model.HealthCheckReply{
                Status:  reply.Status,
                Details: reply.Details,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package biz

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "time"

        "connect-go-example/internal/biz/model"
        conf "connect-go-example/internal/conf/v1"
        "connect-go-example/internal/data"

        "connectrpc.com/connect"
        "github.com/golang-jwt/jwt/v5"
        "go.uber.org/zap"
)

type UserUseCase struct {
        repo   data.UserRepo
        cfg    *conf.Auth
        secret []byte
}

func NewUserUseCase(repo data.UserRepo, cfg *conf.Bootstrap, logger *zap.Logger) (model.UserUseCase, error) <span class="cov8" title="1">{
        var secret []byte
        if cfg.Auth.JwtSecret != "" </span><span class="cov8" title="1">{
                secret = []byte(cfg.Auth.JwtSecret)
        }</span> else<span class="cov8" title="1"> {
                // 生成默认密钥
                secret = make([]byte, 32)
                if _, err := rand.Read(secret); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generate jwt secret failed: %v", err)
                }</span>
                <span class="cov8" title="1">logger.Warn("WARNING: Using auto-generated JWT secret, set auth.jwt_secret in config for production")</span>
        }

        <span class="cov8" title="1">return &amp;UserUseCase{
                repo:   repo,
                cfg:    cfg.Auth,
                secret: secret,
        }, nil</span>
}

func (uc *UserUseCase) Register(ctx context.Context, username, passwordHash, email, salt string) (string, error) <span class="cov8" title="1">{
        // 检查用户是否已存在
        existingUser, err := uc.repo.GetUserByName(ctx, username)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov8" title="1">{
                return "", connect.NewError(connect.CodeAlreadyExists, errors.New("user already exists"))
        }</span>

        // 创建用户
        <span class="cov8" title="1">userID, err := uc.repo.CreateUser(ctx, &amp;model.User{
                Username:     username,
                PasswordHash: passwordHash,
                Email:        email,
                Salt:         salt,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%d", userID), nil</span>
}

func (uc *UserUseCase) GetAuthChallenge(ctx context.Context, username string) (*model.AuthChallenge, error) <span class="cov8" title="1">{
        // 获取用户信息
        user, err := uc.repo.GetUserByName(ctx, username)
        if err != nil </span><span class="cov8" title="1">{
                // 返回通用错误避免用户枚举
                return nil, errors.New("authentication failed")
        }</span>

        // 生成随机挑战
        <span class="cov8" title="1">challenge := make([]byte, 32)
        if _, err := rand.Read(challenge); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate challenge failed: %v", err)
        }</span>
        <span class="cov8" title="1">challengeStr := base64.StdEncoding.EncodeToString(challenge)

        // 存储挑战到缓存
        timeout := time.Duration(uc.cfg.ChallengeTimeoutSeconds) * time.Second
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 2 * time.Minute // 默认2分钟
        }</span>

        <span class="cov8" title="1">if err := uc.repo.StoreAuthChallenge(ctx, username, challengeStr, timeout); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("store auth challenge failed: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;model.AuthChallenge{
                Username:  username,
                Challenge: challengeStr,
                Salt:      user.Salt,
        }, nil</span>
}

func (uc *UserUseCase) SubmitAuth(ctx context.Context, username, hashedCredential, authRequestID, challengeResponse string) (*model.AuthResult, error) <span class="cov8" title="1">{
        // 验证挑战响应
        expectedChallenge, err := uc.repo.GetAuthChallenge(ctx, username)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid or expired challenge")
        }</span>

        // 计算期望的挑战响应
        <span class="cov0" title="0">expectedResponse := computeChallengeResponse(expectedChallenge, username)
        if challengeResponse != expectedResponse </span><span class="cov0" title="0">{
                return nil, errors.New("invalid challenge response")
        }</span>

        // 获取用户信息
        <span class="cov0" title="0">user, err := uc.repo.GetUserByName(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("authentication failed")
        }</span>

        // 验证凭证
        <span class="cov0" title="0">if !constantTimeCompare(hashedCredential, user.PasswordHash) </span><span class="cov0" title="0">{
                return nil, errors.New("authentication failed")
        }</span>

        // 生成JWT令牌
        <span class="cov0" title="0">token, err := uc.generateJWT(user.ID, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate token failed: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;model.AuthResult{
                Code:      "success",
                State:     "authenticated",
                AuthToken: token,
        }, nil</span>
}

func (uc *UserUseCase) generateJWT(userID int64, username string) (string, error) <span class="cov8" title="1">{
        expireHours := uc.cfg.JwtExpireHours
        if expireHours == 0 </span><span class="cov0" title="0">{
                expireHours = 24 // 默认24小时
        }</span>

        <span class="cov8" title="1">claims := jwt.MapClaims{
                "sub": userID,
                "usr": username,
                "iat": time.Now().Unix(),
                "exp": time.Now().Add(time.Duration(expireHours) * time.Hour).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(uc.secret)</span>
}

func computeChallengeResponse(challenge, username string) string <span class="cov0" title="0">{
        str := fmt.Sprintf("%s:%s:%d", challenge, username, time.Now().Unix()/30)
        hash := sha256.Sum256([]byte(str))
        return hex.EncodeToString(hash[:])
}</span>

func constantTimeCompare(a, b string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">result := 0
        for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="1">{
                result |= int(a[i]) ^ int(b[i])
        }</span>
        <span class="cov8" title="1">return result == 0</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.10
//         protoc        (unknown)
// source: internal/conf/v1/conf.proto

package confv1

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Bootstrap struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Server        *Server                `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
        Data          *Data                  `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
        Auth          *Auth                  `protobuf:"bytes,3,opt,name=auth,proto3" json:"auth,omitempty"`
        Trace         *Trace                 `protobuf:"bytes,4,opt,name=trace,proto3" json:"trace,omitempty"`
        Discovery     *Discovery             `protobuf:"bytes,5,opt,name=discovery,proto3" json:"discovery,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Bootstrap) Reset() <span class="cov0" title="0">{
        *x = Bootstrap{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Bootstrap) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Bootstrap) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Bootstrap) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Bootstrap.ProtoReflect.Descriptor instead.
func (*Bootstrap) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Bootstrap) GetServer() *Server <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Server
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetData() *Data <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetAuth() *Auth <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Auth
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetTrace() *Trace <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trace
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Bootstrap) GetDiscovery() *Discovery <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Discovery
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Http          *Server_HTTP           `protobuf:"bytes,1,opt,name=http,proto3" json:"http,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server) Reset() <span class="cov0" title="0">{
        *x = Server{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server.ProtoReflect.Descriptor instead.
func (*Server) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Server) GetHttp() *Server_HTTP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Http
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Database      *Data_Database         `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
        Redis         *Data_Redis            `protobuf:"bytes,2,opt,name=redis,proto3" json:"redis,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data) Reset() <span class="cov0" title="0">{
        *x = Data{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Data) GetDatabase() *Data_Database <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Data) GetRedis() *Data_Redis <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Redis
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Auth struct {
        state                   protoimpl.MessageState `protogen:"open.v1"`
        JwtSecret               string                 `protobuf:"bytes,1,opt,name=jwt_secret,json=jwtSecret,proto3" json:"jwt_secret,omitempty"`
        JwtExpireHours          int64                  `protobuf:"varint,2,opt,name=jwt_expire_hours,json=jwtExpireHours,proto3" json:"jwt_expire_hours,omitempty"`
        ChallengeTimeoutSeconds int64                  `protobuf:"varint,3,opt,name=challenge_timeout_seconds,json=challengeTimeoutSeconds,proto3" json:"challenge_timeout_seconds,omitempty"`
        unknownFields           protoimpl.UnknownFields
        sizeCache               protoimpl.SizeCache
}

func (x *Auth) Reset() <span class="cov0" title="0">{
        *x = Auth{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Auth) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Auth) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Auth) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Auth.ProtoReflect.Descriptor instead.
func (*Auth) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Auth) GetJwtSecret() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JwtSecret
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Auth) GetJwtExpireHours() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JwtExpireHours
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Auth) GetChallengeTimeoutSeconds() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ChallengeTimeoutSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Trace struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Endpoint      string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
        Insecure      bool                   `protobuf:"varint,2,opt,name=insecure,proto3" json:"insecure,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Trace) Reset() <span class="cov0" title="0">{
        *x = Trace{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Trace) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Trace) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Trace) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Trace.ProtoReflect.Descriptor instead.
func (*Trace) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Trace) GetEndpoint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trace) GetInsecure() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Insecure
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Discovery struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Consul        *Discovery_Consul      `protobuf:"bytes,1,opt,name=consul,proto3" json:"consul,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Discovery) Reset() <span class="cov0" title="0">{
        *x = Discovery{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Discovery) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Discovery) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Discovery) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Discovery.ProtoReflect.Descriptor instead.
func (*Discovery) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{5}
}</span>

func (x *Discovery) GetConsul() *Discovery_Consul <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consul
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Server_HTTP struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Addr          string                 `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
        Timeout       int64                  `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Server_HTTP) Reset() <span class="cov0" title="0">{
        *x = Server_HTTP{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Server_HTTP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Server_HTTP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Server_HTTP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Server_HTTP.ProtoReflect.Descriptor instead.
func (*Server_HTTP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *Server_HTTP) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Server_HTTP) GetTimeout() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timeout
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Data_Database struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        Port          int32                  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
        User          string                 `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
        Password      string                 `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
        DbName        string                 `protobuf:"bytes,5,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
        SslMode       string                 `protobuf:"bytes,6,opt,name=ssl_mode,json=sslMode,proto3" json:"ssl_mode,omitempty"`
        Timezone      string                 `protobuf:"bytes,7,opt,name=timezone,proto3" json:"timezone,omitempty"`
        Pool          *Data_DatabasePool     `protobuf:"bytes,8,opt,name=pool,proto3" json:"pool,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data_Database) Reset() <span class="cov0" title="0">{
        *x = Data_Database{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Database) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Database) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Database) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Database.ProtoReflect.Descriptor instead.
func (*Data_Database) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{2, 0}
}</span>

func (x *Data_Database) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Database) GetUser() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetDbName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DbName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetSslMode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SslMode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetTimezone() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timezone
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Database) GetPool() *Data_DatabasePool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pool
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Data_DatabasePool struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        MaxConns        int32                  `protobuf:"varint,1,opt,name=max_conns,json=maxConns,proto3" json:"max_conns,omitempty"`
        MinConns        int32                  `protobuf:"varint,2,opt,name=min_conns,json=minConns,proto3" json:"min_conns,omitempty"`
        MaxConnLifetime int64                  `protobuf:"varint,3,opt,name=max_conn_lifetime,json=maxConnLifetime,proto3" json:"max_conn_lifetime,omitempty"`
        MaxConnIdleTime int64                  `protobuf:"varint,4,opt,name=max_conn_idle_time,json=maxConnIdleTime,proto3" json:"max_conn_idle_time,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Data_DatabasePool) Reset() <span class="cov0" title="0">{
        *x = Data_DatabasePool{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_DatabasePool) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_DatabasePool) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_DatabasePool) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_DatabasePool.ProtoReflect.Descriptor instead.
func (*Data_DatabasePool) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{2, 1}
}</span>

func (x *Data_DatabasePool) GetMaxConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabasePool) GetMinConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabasePool) GetMaxConnLifetime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxConnLifetime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_DatabasePool) GetMaxConnIdleTime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxConnIdleTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Data_Redis struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Host          string                 `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        Port          int32                  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
        Username      string                 `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
        Password      string                 `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
        Db            int32                  `protobuf:"varint,5,opt,name=db,proto3" json:"db,omitempty"`
        DialTimeout   int64                  `protobuf:"varint,6,opt,name=dial_timeout,json=dialTimeout,proto3" json:"dial_timeout,omitempty"`
        ReadTimeout   int64                  `protobuf:"varint,7,opt,name=read_timeout,json=readTimeout,proto3" json:"read_timeout,omitempty"`
        WriteTimeout  int64                  `protobuf:"varint,8,opt,name=write_timeout,json=writeTimeout,proto3" json:"write_timeout,omitempty"`
        PoolSize      int32                  `protobuf:"varint,9,opt,name=pool_size,json=poolSize,proto3" json:"pool_size,omitempty"`
        MinIdleConns  int32                  `protobuf:"varint,10,opt,name=min_idle_conns,json=minIdleConns,proto3" json:"min_idle_conns,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Data_Redis) Reset() <span class="cov0" title="0">{
        *x = Data_Redis{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Data_Redis) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Data_Redis) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Data_Redis) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Data_Redis.ProtoReflect.Descriptor instead.
func (*Data_Redis) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{2, 2}
}</span>

func (x *Data_Redis) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Data_Redis) GetDb() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Db
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetDialTimeout() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DialTimeout
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetReadTimeout() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadTimeout
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetWriteTimeout() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WriteTimeout
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetPoolSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PoolSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Data_Redis) GetMinIdleConns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinIdleConns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Discovery_Consul struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Addr          string                 `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
        Scheme        string                 `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
        HealthCheck   bool                   `protobuf:"varint,3,opt,name=health_check,json=healthCheck,proto3" json:"health_check,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Discovery_Consul) Reset() <span class="cov0" title="0">{
        *x = Discovery_Consul{}
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Discovery_Consul) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Discovery_Consul) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Discovery_Consul) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_conf_v1_conf_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Discovery_Consul.ProtoReflect.Descriptor instead.
func (*Discovery_Consul) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_conf_v1_conf_proto_rawDescGZIP(), []int{5, 0}
}</span>

func (x *Discovery_Consul) GetAddr() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Addr
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Discovery_Consul) GetScheme() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scheme
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Discovery_Consul) GetHealthCheck() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HealthCheck
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_internal_conf_v1_conf_proto protoreflect.FileDescriptor

const file_internal_conf_v1_conf_proto_rawDesc = "" +
        "\n" +
        "\x1binternal/conf/v1/conf.proto\x12\aconf.v1\"\xd2\x01\n" +
        "\tBootstrap\x12'\n" +
        "\x06server\x18\x01 \x01(\v2\x0f.conf.v1.ServerR\x06server\x12!\n" +
        "\x04data\x18\x02 \x01(\v2\r.conf.v1.DataR\x04data\x12!\n" +
        "\x04auth\x18\x03 \x01(\v2\r.conf.v1.AuthR\x04auth\x12$\n" +
        "\x05trace\x18\x04 \x01(\v2\x0e.conf.v1.TraceR\x05trace\x120\n" +
        "\tdiscovery\x18\x05 \x01(\v2\x12.conf.v1.DiscoveryR\tdiscovery\"h\n" +
        "\x06Server\x12(\n" +
        "\x04http\x18\x01 \x01(\v2\x14.conf.v1.Server.HTTPR\x04http\x1a4\n" +
        "\x04HTTP\x12\x12\n" +
        "\x04addr\x18\x01 \x01(\tR\x04addr\x12\x18\n" +
        "\atimeout\x18\x02 \x01(\x03R\atimeout\"\x96\x06\n" +
        "\x04Data\x122\n" +
        "\bdatabase\x18\x01 \x01(\v2\x16.conf.v1.Data.DatabaseR\bdatabase\x12)\n" +
        "\x05redis\x18\x02 \x01(\v2\x13.conf.v1.Data.RedisR\x05redis\x1a\xe2\x01\n" +
        "\bDatabase\x12\x12\n" +
        "\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n" +
        "\x04port\x18\x02 \x01(\x05R\x04port\x12\x12\n" +
        "\x04user\x18\x03 \x01(\tR\x04user\x12\x1a\n" +
        "\bpassword\x18\x04 \x01(\tR\bpassword\x12\x17\n" +
        "\adb_name\x18\x05 \x01(\tR\x06dbName\x12\x19\n" +
        "\bssl_mode\x18\x06 \x01(\tR\asslMode\x12\x1a\n" +
        "\btimezone\x18\a \x01(\tR\btimezone\x12.\n" +
        "\x04pool\x18\b \x01(\v2\x1a.conf.v1.Data.DatabasePoolR\x04pool\x1a\xa1\x01\n" +
        "\fDatabasePool\x12\x1b\n" +
        "\tmax_conns\x18\x01 \x01(\x05R\bmaxConns\x12\x1b\n" +
        "\tmin_conns\x18\x02 \x01(\x05R\bminConns\x12*\n" +
        "\x11max_conn_lifetime\x18\x03 \x01(\x03R\x0fmaxConnLifetime\x12+\n" +
        "\x12max_conn_idle_time\x18\x04 \x01(\x03R\x0fmaxConnIdleTime\x1a\xa5\x02\n" +
        "\x05Redis\x12\x12\n" +
        "\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n" +
        "\x04port\x18\x02 \x01(\x05R\x04port\x12\x1a\n" +
        "\busername\x18\x03 \x01(\tR\busername\x12\x1a\n" +
        "\bpassword\x18\x04 \x01(\tR\bpassword\x12\x0e\n" +
        "\x02db\x18\x05 \x01(\x05R\x02db\x12!\n" +
        "\fdial_timeout\x18\x06 \x01(\x03R\vdialTimeout\x12!\n" +
        "\fread_timeout\x18\a \x01(\x03R\vreadTimeout\x12#\n" +
        "\rwrite_timeout\x18\b \x01(\x03R\fwriteTimeout\x12\x1b\n" +
        "\tpool_size\x18\t \x01(\x05R\bpoolSize\x12$\n" +
        "\x0emin_idle_conns\x18\n" +
        " \x01(\x05R\fminIdleConns\"\x8b\x01\n" +
        "\x04Auth\x12\x1d\n" +
        "\n" +
        "jwt_secret\x18\x01 \x01(\tR\tjwtSecret\x12(\n" +
        "\x10jwt_expire_hours\x18\x02 \x01(\x03R\x0ejwtExpireHours\x12:\n" +
        "\x19challenge_timeout_seconds\x18\x03 \x01(\x03R\x17challengeTimeoutSeconds\"?\n" +
        "\x05Trace\x12\x1a\n" +
        "\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x1a\n" +
        "\binsecure\x18\x02 \x01(\bR\binsecure\"\x97\x01\n" +
        "\tDiscovery\x121\n" +
        "\x06consul\x18\x01 \x01(\v2\x19.conf.v1.Discovery.ConsulR\x06consul\x1aW\n" +
        "\x06Consul\x12\x12\n" +
        "\x04addr\x18\x01 \x01(\tR\x04addr\x12\x16\n" +
        "\x06scheme\x18\x02 \x01(\tR\x06scheme\x12!\n" +
        "\fhealth_check\x18\x03 \x01(\bR\vhealthCheckB|\n" +
        "\vcom.conf.v1B\tConfProtoP\x01Z%connect-go-example/gen/conf/v1;confv1\xa2\x02\x03CXX\xaa\x02\aConf.V1\xca\x02\aConf\\V1\xe2\x02\x13Conf\\V1\\GPBMetadata\xea\x02\bConf::V1b\x06proto3"

var (
        file_internal_conf_v1_conf_proto_rawDescOnce sync.Once
        file_internal_conf_v1_conf_proto_rawDescData []byte
)

func file_internal_conf_v1_conf_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_internal_conf_v1_conf_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_internal_conf_v1_conf_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_internal_conf_v1_conf_proto_rawDesc), len(file_internal_conf_v1_conf_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_internal_conf_v1_conf_proto_rawDescData</span>
}

var (
        file_internal_conf_v1_conf_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
        file_internal_conf_v1_conf_proto_goTypes  = []any{
                (*Bootstrap)(nil),         // 0: conf.v1.Bootstrap
                (*Server)(nil),            // 1: conf.v1.Server
                (*Data)(nil),              // 2: conf.v1.Data
                (*Auth)(nil),              // 3: conf.v1.Auth
                (*Trace)(nil),             // 4: conf.v1.Trace
                (*Discovery)(nil),         // 5: conf.v1.Discovery
                (*Server_HTTP)(nil),       // 6: conf.v1.Server.HTTP
                (*Data_Database)(nil),     // 7: conf.v1.Data.Database
                (*Data_DatabasePool)(nil), // 8: conf.v1.Data.DatabasePool
                (*Data_Redis)(nil),        // 9: conf.v1.Data.Redis
                (*Discovery_Consul)(nil),  // 10: conf.v1.Discovery.Consul
        }
)

var file_internal_conf_v1_conf_proto_depIdxs = []int32{
        1,  // 0: conf.v1.Bootstrap.server:type_name -&gt; conf.v1.Server
        2,  // 1: conf.v1.Bootstrap.data:type_name -&gt; conf.v1.Data
        3,  // 2: conf.v1.Bootstrap.auth:type_name -&gt; conf.v1.Auth
        4,  // 3: conf.v1.Bootstrap.trace:type_name -&gt; conf.v1.Trace
        5,  // 4: conf.v1.Bootstrap.discovery:type_name -&gt; conf.v1.Discovery
        6,  // 5: conf.v1.Server.http:type_name -&gt; conf.v1.Server.HTTP
        7,  // 6: conf.v1.Data.database:type_name -&gt; conf.v1.Data.Database
        9,  // 7: conf.v1.Data.redis:type_name -&gt; conf.v1.Data.Redis
        10, // 8: conf.v1.Discovery.consul:type_name -&gt; conf.v1.Discovery.Consul
        8,  // 9: conf.v1.Data.Database.pool:type_name -&gt; conf.v1.Data.DatabasePool
        10, // [10:10] is the sub-list for method output_type
        10, // [10:10] is the sub-list for method input_type
        10, // [10:10] is the sub-list for extension type_name
        10, // [10:10] is the sub-list for extension extendee
        0,  // [0:10] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_internal_conf_v1_conf_proto_init() }</span>
func file_internal_conf_v1_conf_proto_init() <span class="cov0" title="0">{
        if File_internal_conf_v1_conf_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_internal_conf_v1_conf_proto_rawDesc), len(file_internal_conf_v1_conf_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   11,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_internal_conf_v1_conf_proto_goTypes,
                DependencyIndexes: file_internal_conf_v1_conf_proto_depIdxs,
                MessageInfos:      file_internal_conf_v1_conf_proto_msgTypes,
        }.Build()
        File_internal_conf_v1_conf_proto = out.File
        file_internal_conf_v1_conf_proto_goTypes = nil
        file_internal_conf_v1_conf_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package data

import (
        "context"

        "connect-go-example/internal/biz/model"

        "connectrpc.com/connect"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/redis/go-redis/v9"
        "go.uber.org/zap"
)

type checkRepo struct {
        pool *pgxpool.Pool
        rdb  *redis.Client
        l    *zap.Logger
}

type CheckRepo interface {
        Ready(context.Context, model.HealthCheckReq) (model.HealthCheckReply, error)
}

func NewCheckRepo(pool *pgxpool.Pool, rdb *redis.Client,
        l *zap.Logger,
) CheckRepo <span class="cov8" title="1">{
        return &amp;checkRepo{
                pool: pool,
                rdb:  rdb,
                l:    l,
        }
}</span>

func (c checkRepo) Ready(ctx context.Context, _ model.HealthCheckReq) (model.HealthCheckReply, error) <span class="cov0" title="0">{
        err := c.pool.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return model.HealthCheckReply{
                        Status: "Unhealthy",
                        Details: map[string]string{
                                "Message": err.Error(),
                        },
                }, connect.NewError(connect.CodeUnavailable, err)
        }</span>
        <span class="cov0" title="0">if err := c.rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return model.HealthCheckReply{
                        Status: "Unhealthy",
                        Details: map[string]string{
                                "Components": "Redis",
                                "Message":    err.Error(),
                        },
                }, connect.NewError(connect.CodeUnavailable, err)
        }</span>
        <span class="cov0" title="0">return model.HealthCheckReply{
                Status:  "Ready",
                Details: nil,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package data

import (
        "context"
        "fmt"
        "time"

        conf "connect-go-example/internal/conf/v1"

        "github.com/exaring/otelpgx"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/redis/go-redis/v9"
        "go.uber.org/fx"
        "go.uber.org/zap"
)

// Module 导出给 FX 的 Provider
var Module = fx.Module("data",
        fx.Provide(
                NewData,
                NewDB,
                NewCache,
                NewUserRepo,
                NewCheckRepo,
        ),
)

// Data 包含所有数据源的客户端
type Data struct {
        db  *pgxpool.Pool
        rdb *redis.Client
}

// NewData 是 Data 的构造函数
func NewData(db *pgxpool.Pool, rdb *redis.Client) *Data <span class="cov8" title="1">{
        return &amp;Data{
                db:  db,
                rdb: rdb,
        }
}</span>

// NewDB 创建数据库连接池
func NewDB(lc fx.Lifecycle, cfg *conf.Bootstrap, logger *zap.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        dbCfg := cfg.Data.Database // 从 Config 中获取 Data 配置

        connString := fmt.Sprintf("postgresql://%s:%s@%s:%d/%s?sslmode=%s&amp;timezone=%s",
                dbCfg.User,
                dbCfg.Password,
                dbCfg.Host,
                dbCfg.Port,
                dbCfg.DbName,
                dbCfg.SslMode,
                dbCfg.Timezone,
        )

        poolCfg, err := pgxpool.ParseConfig(connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse database config failed: %v", err)
        }</span>

        // 链路追踪配置
        <span class="cov0" title="0">poolCfg.ConnConfig.Tracer = otelpgx.NewTracer()

        // 创建连接池
        pool, err := pgxpool.NewWithConfig(context.Background(), poolCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connect to database failed: %v", err)
        }</span>

        // 记录数据库统计信息
        <span class="cov0" title="0">if err := otelpgx.RecordStats(pool); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to record database stats: %w", err)
        }</span>

        // 测试连接
        <span class="cov0" title="0">if err := pool.Ping(context.Background()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database ping failed: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("dbCfg:%+v", dbCfg)
        // 注册关闭钩子
        lc.Append(fx.Hook{
                OnStop: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        logger.Info("Closing database connection...")
                        pool.Close()
                        return nil
                }</span>,
        })

        <span class="cov0" title="0">return pool, nil</span>
}

// NewCache 创建 Redis 客户端
func NewCache(lc fx.Lifecycle, cfg *conf.Bootstrap, logger *zap.Logger) (*redis.Client, error) <span class="cov0" title="0">{
        redisCfg := cfg.Data.Redis // 从 Config 中获取 Redis 配置

        rdb := redis.NewClient(&amp;redis.Options{
                Addr:         fmt.Sprintf("%s:%d", redisCfg.Host, redisCfg.Port),
                Username:     redisCfg.Username,
                Password:     redisCfg.Password,
                DB:           int(redisCfg.Db),
                DialTimeout:  time.Duration(redisCfg.DialTimeout) * time.Second,
                ReadTimeout:  time.Duration(redisCfg.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(redisCfg.WriteTimeout) * time.Second,
                PoolSize:     int(redisCfg.PoolSize),
                MinIdleConns: int(redisCfg.MinIdleConns),
        })

        // 测试连接
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                // 关闭连接以避免资源泄漏
                err := rdb.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("redis ping failed: %v", err)</span>
        }

        <span class="cov0" title="0">logger.Info(fmt.Sprintf("Redis connected successfully to %s", redisCfg.Host))

        // 注册关闭钩子
        lc.Append(fx.Hook{
                OnStop: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        logger.Info("Closing Redis connection...")
                        return rdb.Close()
                }</span>,
        })

        <span class="cov0" title="0">return rdb, nil</span>
}

// HealthCheck 健康检查
func (d *Data) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        if err := d.db.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database health check failed: %v", err)
        }</span>

        <span class="cov0" title="0">if err := d.rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis health check failed: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package models

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov8" title="1">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package models

import (
        "context"
)

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (username, password_hash, salt)
VALUES ($1, $2, $3)
RETURNING id, username, password_hash, salt, created_at, updated_at
`

type CreateUserParams struct {
        Username     string
        PasswordHash string
        Salt         string
}

// CreateUser
//
//        INSERT INTO users (username, password_hash, salt)
//        VALUES ($1, $2, $3)
//        RETURNING id, username, password_hash, salt, created_at, updated_at
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRow(ctx, CreateUser, arg.Username, arg.PasswordHash, arg.Salt)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.Salt,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const GetUserByName = `-- name: GetUserByName :one
SELECT username, salt, id, password_hash
FROM users
WHERE username = $1
`

type GetUserByNameRow struct {
        Username     string
        Salt         string
        ID           int32
        PasswordHash string
}

// GetUserByName
//
//        SELECT username, salt, id, password_hash
//        FROM users
//        WHERE username = $1
func (q *Queries) GetUserByName(ctx context.Context, username string) (GetUserByNameRow, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, GetUserByName, username)
        var i GetUserByNameRow
        err := row.Scan(
                &amp;i.Username,
                &amp;i.Salt,
                &amp;i.ID,
                &amp;i.PasswordHash,
        )
        return i, err
}</span>

const InsertTestUser = `-- name: InsertTestUser :one
INSERT INTO users(username, password_hash, salt)
VALUES ('admin', 'asdas', '123123')
RETURNING id, username, password_hash, salt, created_at, updated_at
`

// InsertTestUser
//
//        INSERT INTO users(username, password_hash, salt)
//        VALUES ('admin', 'asdas', '123123')
//        RETURNING id, username, password_hash, salt, created_at, updated_at
func (q *Queries) InsertTestUser(ctx context.Context) (User, error) <span class="cov8" title="1">{
        row := q.db.QueryRow(ctx, InsertTestUser)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Username,
                &amp;i.PasswordHash,
                &amp;i.Salt,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package data

import (
        "context"
        "fmt"
        "time"

        "connect-go-example/internal/biz/model"
        "connect-go-example/internal/data/models"

        "github.com/redis/go-redis/v9"
        "go.uber.org/zap"
)

// UserRepo 用户数据访问接口
type UserRepo interface {
        GetUserByName(ctx context.Context, username string) (*model.User, error)
        CreateUser(ctx context.Context, user *model.User) (int64, error)
        StoreAuthChallenge(ctx context.Context, username, challenge string, timeout time.Duration) error
        GetAuthChallenge(ctx context.Context, username string) (string, error)
}

type userRepo struct {
        queries *models.Queries
        rdb     *redis.Client
        l       *zap.Logger
}

func NewUserRepo(data *Data, logger *zap.Logger) UserRepo <span class="cov0" title="0">{
        return &amp;userRepo{
                queries: models.New(data.db),
                rdb:     data.rdb,
                l:       logger,
        }
}</span>

func (r *userRepo) GetUserByName(ctx context.Context, username string) (*model.User, error) <span class="cov0" title="0">{
        dbUser, err := r.queries.GetUserByName(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;model.User{
                ID:           int64(dbUser.ID),
                Username:     dbUser.Username,
                PasswordHash: dbUser.PasswordHash,
                Salt:         dbUser.Salt,
                // Email:        dbUser.Email,
                // CreatedAt:    dbUser.CreatedAt.Time().Format(time.RFC3339),
        }, nil</span>
}

func (r *userRepo) CreateUser(ctx context.Context, req *model.User) (int64, error) <span class="cov0" title="0">{
        params := models.CreateUserParams{
                Username:     req.Username,
                PasswordHash: req.PasswordHash,
                Salt:         req.Salt,
                // Email:        user.Email,
        }

        user, err := r.queries.CreateUser(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int64(user.ID), nil</span>
}

func (r *userRepo) StoreAuthChallenge(ctx context.Context, username, challenge string, timeout time.Duration) error <span class="cov0" title="0">{
        key := fmt.Sprintf("auth_challenge:%s", username)
        return r.rdb.SetEx(ctx, key, challenge, timeout).Err()
}</span>

func (r *userRepo) GetAuthChallenge(ctx context.Context, username string) (string, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("auth_challenge:%s", username)
        challenge, err := r.rdb.GetDel(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return challenge, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "fmt"
        "os"

        confv1 "connect-go-example/internal/conf/v1"

        "github.com/mitchellh/mapstructure"
        "github.com/spf13/viper"
        "go.uber.org/fx"
)

var (
        conf = &amp;confv1.Bootstrap{}
        // Module 提供 Fx 模块
        Module = fx.Module("config",
                fx.Provide(
                        // 提供配置加载函数
                        func() (*confv1.Bootstrap, error) <span class="cov0" title="0">{
                                // 从环境变量获取配置路径，如果没有设置则使用默认路径
                                configPath := getConfigPath()

                                conf := Init(configPath)
                                if conf != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Configuration loaded successfully from: %s\n", configPath)
                                        return conf, nil
                                }</span>

                                <span class="cov0" title="0">return nil, nil</span>
                        },
                ),
        )
)

// Init 初始化配置加载，仅从本地文件读取
func Init(configPath string) *confv1.Bootstrap <span class="cov8" title="1">{
        v := viper.New()
        v.SetConfigFile(configPath)
        v.SetConfigType("yaml")

        localConf := &amp;confv1.Bootstrap{}

        // 从本地文件读取配置
        if err := v.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                // 使用标准输出而不是logger，因为logger可能还没有初始化
                fmt.Printf("Warning: Error reading config file %s: %v\n", configPath, err)
                return nil
        }</span>

        // 获取 Viper 的所有配置为一个 map
        <span class="cov0" title="0">m := v.AllSettings()
        decoder, err := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{
                Metadata: nil,
                // 允许将 snake_case 键与 CamelCase 字段匹配
                TagName: "json", // 明确告诉 mapstructure 使用 json tag（Protobuf 结构体自带）
                Result:  localConf,
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to create decoder: %v\n", err)
                return nil
        }</span>

        <span class="cov0" title="0">if err := decoder.Decode(m); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Unable to decode config map into struct: %v\n", err)
                return nil
        }</span>

        // 3. (可选) 监听本地文件变化 - 在生产环境中禁用
        // v.WatchConfig()
        // v.OnConfigChange(func(e fsnotify.Event) {
        //         logger.Error("Config file changed:" + e.Name)
        //         if err := v.Unmarshal(conf); err != nil {
        //                 logger.Error("Unable to decode into struct on change, %v" + err.Error())
        //         }
        // })

        <span class="cov0" title="0">return localConf</span>
}

// GetConfig 返回已加载的配置
func GetConfig() *confv1.Bootstrap <span class="cov8" title="1">{
        return conf
}</span>

// getConfigPath 从环境变量获取配置路径
func getConfigPath() string <span class="cov8" title="1">{
        // 优先使用环境变量 CONFIG_PATH
        if configPath := os.Getenv("CONFIG_PATH"); configPath != "" </span><span class="cov8" title="1">{
                return configPath
        }</span>

        // 如果没有设置环境变量，根据运行环境返回默认路径
        // 在Docker容器中，配置文件位于/app/configs/config.yaml
        // 在开发环境中，配置文件位于configs/config.yaml
        <span class="cov8" title="1">if isRunningInContainer() </span><span class="cov0" title="0">{
                return "/app/configs/config.yaml"
        }</span>

        <span class="cov8" title="1">return "configs/config.yaml"</span>
}

// isRunningInContainer 检查是否在容器中运行
func isRunningInContainer() bool <span class="cov8" title="1">{
        // 检查常见的容器环境指示器
        // 1. 检查/.dockerenv文件是否存在
        if _, err := os.Stat("/.dockerenv"); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // 2. 检查/proc/1/cgroup文件内容
        <span class="cov8" title="1">if cgroup, err := os.ReadFile("/proc/1/cgroup"); err == nil </span><span class="cov0" title="0">{
                if contains(string(cgroup), "docker") || contains(string(cgroup), "kubepods") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // 3. 检查容器相关的环境变量
        <span class="cov8" title="1">if os.Getenv("KUBERNETES_SERVICE_HOST") != "" || os.Getenv("CONTAINER") != "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// contains 检查字符串是否包含子字符串
func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(s) &gt; 0 &amp;&amp; (s[0:len(substr)] == substr || contains(s[1:], substr)))
}</span>

// ValidateConfig 验证配置的完整性
func ValidateConfig(conf *confv1.Bootstrap) error <span class="cov8" title="1">{
        if conf == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration is nil")
        }</span>

        // 验证服务器配置
        <span class="cov8" title="1">if conf.Server == nil || conf.Server.Http == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("server configuration is required")
        }</span>

        // 验证数据库配置
        <span class="cov8" title="1">if conf.Data == nil || conf.Data.Database == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("database configuration is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package log

import (
        confv1 "connect-go-example/internal/conf/v1"

        "go.uber.org/fx"
        "go.uber.org/zap"
)

// Module 提供 Fx 模块
var Module = fx.Module("log",
        fx.Provide(
                // 提供日志创建函数
                func(conf *confv1.Bootstrap) (*zap.Logger, error) <span class="cov0" title="0">{
                        runMode := "prod"
                        if conf.Server != nil &amp;&amp; conf.Server.Http != nil </span><span class="cov0" title="0">{
                                // 可以根据配置中的其他字段来决定运行模式
                                // 例如：如果配置了开发环境特定的设置，则使用 "dev"
                                runMode = "prod"
                        }</span>
                        <span class="cov0" title="0">return NewLogger(runMode)</span>
                },
        ),
)

// NewLogger 创建一个新的 Zap Logger
func NewLogger(runMode string) (*zap.Logger, error) <span class="cov8" title="1">{
        if runMode == "dev" </span><span class="cov8" title="1">{
                return zap.NewDevelopment()
        }</span>
        <span class="cov8" title="1">return zap.NewProduction()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package otel

import (
        "context"
        "errors"
        "time"

        confv1 "connect-go-example/internal/conf/v1"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploghttp"
        "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/log/global"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/log"
        "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
        "go.uber.org/fx"
        "go.uber.org/zap"
)

var (
        // OTLP 端点变量
        endpoint string
        // Module 提供 Fx 模块
        Module = fx.Module("otel",
                fx.Provide(
                        // 提供 OpenTelemetry 设置函数
                        func(cfg *confv1.Trace, logger *zap.Logger) (func(context.Context) error, error) <span class="cov0" title="0">{
                                return SetupOTelSDK(context.Background(), cfg, logger)
                        }</span>,
                ),
        )
)

// SetEndpoint 从配置中设置端点
func SetEndpoint(cfg *confv1.Trace, logger *zap.Logger) <span class="cov0" title="0">{
        if cfg != nil &amp;&amp; cfg.Endpoint != "" </span><span class="cov0" title="0">{
                endpoint = cfg.Endpoint
                logger.Info("otlpEndpoint" + endpoint)
        }</span> else<span class="cov0" title="0"> {
                endpoint = ""
                logger.Info("OpenTelemetry disabled - no endpoint configured")
        }</span>
}

// SetupOTelSDK bootstraps the OpenTelemetry pipeline.
func SetupOTelSDK(ctx context.Context, cfg *confv1.Trace, logger *zap.Logger) (func(context.Context) error, error) <span class="cov0" title="0">{
        var shutdownFuncs []func(context.Context) error
        var err error

        shutdown := func(ctx context.Context) error </span><span class="cov0" title="0">{
                var err error
                for _, fn := range shutdownFuncs </span><span class="cov0" title="0">{
                        err = errors.Join(err, fn(ctx))
                }</span>
                <span class="cov0" title="0">shutdownFuncs = nil
                return err</span>
        }

        <span class="cov0" title="0">handleErr := func(inErr error) </span><span class="cov0" title="0">{
                err = errors.Join(inErr, shutdown(ctx))
        }</span>

        // 从配置中设置端点
        <span class="cov0" title="0">SetEndpoint(cfg, logger)

        // 如果没有配置端点，禁用 OpenTelemetry
        if endpoint == "" </span><span class="cov0" title="0">{
                logger.Info("OpenTelemetry disabled - no endpoint configured")
                // 返回空地关闭函数
                return func(ctx context.Context) error </span><span class="cov0" title="0">{ return nil }</span>, nil
        }

        <span class="cov0" title="0">prop := newPropagator()
        otel.SetTextMapPropagator(prop)

        res, err := newResource()
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
                return shutdown, err
        }</span>

        <span class="cov0" title="0">tracerProvider, err := newTracerProvider(res)
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
                return shutdown, err
        }</span>
        <span class="cov0" title="0">shutdownFuncs = append(shutdownFuncs, tracerProvider.Shutdown)
        otel.SetTracerProvider(tracerProvider)

        meterProvider, err := newMeterProvider(res)
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
                return shutdown, err
        }</span>
        <span class="cov0" title="0">shutdownFuncs = append(shutdownFuncs, meterProvider.Shutdown)
        otel.SetMeterProvider(meterProvider)

        loggerProvider, err := newLoggerProvider(res)
        if err != nil </span><span class="cov0" title="0">{
                handleErr(err)
                return shutdown, err
        }</span>
        <span class="cov0" title="0">shutdownFuncs = append(shutdownFuncs, loggerProvider.Shutdown)
        global.SetLoggerProvider(loggerProvider)

        logger.Info("OpenTelemetry enabled - sending data to %s\n" + endpoint)
        return shutdown, err</span>
}

func newResource() (*resource.Resource, error) <span class="cov0" title="0">{
        return resource.Merge(resource.Default(),
                resource.NewWithAttributes(semconv.SchemaURL,
                        semconv.ServiceName("connect-example-go"),
                        semconv.ServiceVersion("1.0.0"),
                ))
}</span>

func newPropagator() propagation.TextMapPropagator <span class="cov0" title="0">{
        return propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        )
}</span>

func newTracerProvider(res *resource.Resource) (*trace.TracerProvider, error) <span class="cov0" title="0">{
        ctx := context.Background()

        traceExporter, err := otlptracehttp.New(
                ctx,
                otlptracehttp.WithEndpoint(endpoint),
                otlptracehttp.WithInsecure(), // 如果没有 TLS，使用此选项
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">bsp := trace.NewBatchSpanProcessor(traceExporter)
        tracerProvider := trace.NewTracerProvider(
                trace.WithSampler(trace.AlwaysSample()),
                trace.WithResource(res),
                trace.WithSpanProcessor(bsp),
        )
        return tracerProvider, nil</span>
}

func newMeterProvider(res *resource.Resource) (*metric.MeterProvider, error) <span class="cov0" title="0">{
        metricExporter, err := otlpmetrichttp.New(
                context.Background(),
                otlpmetrichttp.WithEndpoint(endpoint),
                otlpmetrichttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">meterProvider := metric.NewMeterProvider(
                metric.WithResource(res),
                metric.WithReader(metric.NewPeriodicReader(metricExporter,
                        metric.WithInterval(3*time.Second))),
        )
        return meterProvider, nil</span>
}

func newLoggerProvider(res *resource.Resource) (*log.LoggerProvider, error) <span class="cov0" title="0">{
        logExporter, err := otlploghttp.New(
                context.Background(),
                otlploghttp.WithEndpoint(endpoint),
                otlploghttp.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">loggerProvider := log.NewLoggerProvider(
                log.WithResource(res),
                log.WithProcessor(log.NewBatchProcessor(logExporter)),
        )
        return loggerProvider, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package registry

import (
        "context"
        "fmt"
        "net"
        "os"
        "strconv"
        "time"

        confv1 "connect-go-example/internal/conf/v1"

        "github.com/google/uuid"
        "github.com/hashicorp/consul/api"
        "go.uber.org/fx"
        "go.uber.org/zap"
)

//        TtlDuration 定义了 Consul Agent 期望的心跳时间间隔。
//
// 建议：TTL 持续时间（如 15s）应比心跳间隔（如 5s）长，以提供冗余。
const (
        TtlDuration     = "30s"
        TtlPingInterval = 10 * time.Second
)

type ConsulRegistry struct {
        client       *api.Client
        logger       *zap.Logger
        serviceID    string
        serviceName  string
        registerHost string
        servicePort  int
}

// Module 提供 Fx 模块
var Module = fx.Module("registry",
        fx.Provide(
                // 提供 Consul 注册中心（支持优雅降级）
                func(lc fx.Lifecycle, logger *zap.Logger, conf *confv1.Bootstrap, serviceName string) (*ConsulRegistry, error) <span class="cov0" title="0">{
                        if os.Getenv("DISABLE_CONSUL") == "true" </span><span class="cov0" title="0">{
                                logger.Info("Consul disabled by environment variable DISABLE_CONSUL=true")
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">if conf.Discovery == nil || conf.Discovery.Consul == nil || conf.Discovery.Consul.Addr == "" </span><span class="cov0" title="0">{
                                logger.Info("Consul not configured, service discovery disabled")
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">consulAddr := conf.Discovery.Consul.Addr
                        serviceScheme := conf.Discovery.Consul.Scheme

                        // 解析端口
                        _, portStr, err := net.SplitHostPort(conf.Server.Http.Addr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse service address: %w", err)
                        }</span>
                        <span class="cov0" title="0">servicePort, err := strconv.Atoi(portStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse service port: %w", err)
                        }</span>

                        // 获取 Pod 或机器的 IP 地址
                        <span class="cov0" title="0">registerHost, err := getOutboundIP()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to determine outbound IP: %w", err)
                        }</span>

                        <span class="cov0" title="0">logger.Info("Initializing Consul registry", zap.String("addr", consulAddr), zap.String("registerHost", registerHost))

                        reg, err := NewConsulRegistry(consulAddr, logger, serviceName, servicePort, serviceScheme, registerHost)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to initialize Consul registry, service discovery disabled", zap.Error(err))
                                return nil, nil
                        }</span>

                        // 使用生命周期钩子自动注册、启动心跳和注销
                        <span class="cov0" title="0">lc.Append(fx.Hook{
                                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                                        if err := reg.Register(); err != nil </span><span class="cov0" title="0">{
                                                logger.Warn("Failed to register with Consul, service discovery disabled", zap.Error(err))
                                                return nil // 允许应用继续运行
                                        }</span>

                                        // 启动 TTL 心跳 Pinger
                                        <span class="cov0" title="0">go reg.TtlCheckPinger(context.Background())
                                        return nil</span>
                                },
                                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                                        if reg != nil </span><span class="cov0" title="0">{
                                                // Deregister() 也会停止心跳，但我们不需要显式停止 TtlCheckPinger，
                                                // 因为 Deregister 是 OnStop 的一部分，当应用退出时，TtlCheckPinger 的 context 也会关闭。
                                                if err := reg.Deregister(); err != nil </span><span class="cov0" title="0">{
                                                        logger.Warn("Failed to deregister from Consul", zap.Error(err))
                                                }</span>
                                        }
                                        <span class="cov0" title="0">return nil</span>
                                },
                        })
                        <span class="cov0" title="0">return reg, nil</span>
                },
        ),
)

func NewConsulRegistry(consulAddr string, logger *zap.Logger, serviceName string, servicePort int, serviceScheme string, registerHost string) (*ConsulRegistry, error) <span class="cov0" title="0">{
        config := &amp;api.Config{
                Address: consulAddr,
                Scheme:  serviceScheme,
        }
        client, err := api.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ConsulRegistry{
                client:       client,
                logger:       logger,
                serviceID:    fmt.Sprintf("%s-%s", serviceName, uuid.New().String()),
                serviceName:  serviceName,
                servicePort:  servicePort,
                registerHost: registerHost,
        }, nil</span>
}

// Register 使用 TTL 健康检查注册服务
func (r *ConsulRegistry) Register() error <span class="cov0" title="0">{
        reg := &amp;api.AgentServiceRegistration{
                ID:      r.serviceID,
                Name:    r.serviceName,
                Address: r.registerHost,
                Port:    r.servicePort,
                Tags:    []string{r.serviceName, "fx", "ttl"}, // 增加 'ttl' tag
                Check: &amp;api.AgentServiceCheck{
                        // 1. 使用 TTL 替换 HTTP/TCP 检查
                        TTL: TtlDuration,
                        // 2. 配置在检查失败后自动注销
                        DeregisterCriticalServiceAfter: "1m",
                },
        }

        if err := r.client.Agent().ServiceRegister(reg); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to register service with Consul", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">r.logger.Info("Service registered with Consul using TTL check", zap.String("id", r.serviceID), zap.String("ttl", TtlDuration))
        return nil</span>
}

// TtlCheckPinger 负责定期向 Consul Agent 发送心跳信号
func (r *ConsulRegistry) TtlCheckPinger(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(TtlPingInterval)
        defer ticker.Stop()

        // Consul Agent 要求 CheckID 必须是 "service:&lt;ServiceID&gt;" 的格式
        checkID := fmt.Sprintf("service:%s", r.serviceID)

        r.logger.Info("Starting TTL pinger", zap.Duration("interval", TtlPingInterval), zap.String("checkID", checkID))

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        r.logger.Info("TTL pinger stopped gracefully")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // 发送 'pass' 状态的心跳
                        err := r.client.Agent().UpdateTTL(checkID, "TTL check passing", api.HealthPassing)
                        if err != nil </span><span class="cov0" title="0">{
                                // 记录错误，但不退出 Pinger，因为这可能是暂时的网络问题
                                // 如果长时间失败，Consul Agent 会将服务标记为 Critical
                                r.logger.Error("Failed to update Consul TTL", zap.Error(err), zap.String("serviceID", r.serviceID))
                        }</span>
                }
        }
}

func (r *ConsulRegistry) Deregister() error <span class="cov0" title="0">{
        r.logger.Info("Deregistering service from Consul", zap.String("id", r.serviceID))
        return r.client.Agent().ServiceDeregister(r.serviceID)
}</span>

// getOutboundIP returns the non-loopback local IP of the machine.
func getOutboundIP() (string, error) <span class="cov0" title="0">{
        conn, err := net.Dial("udp", "8.8.8.8:80") // Connect to a public server (doesn't send data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer func(conn net.Conn) </span><span class="cov0" title="0">{
                err := conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }(conn)

        <span class="cov0" title="0">localAddr := conn.LocalAddr().(*net.UDPAddr)
        return localAddr.IP.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "connectrpc.com/connect"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/metric"
        "go.uber.org/fx"
        "go.uber.org/zap"
)

// Metrics 结构体用于存储监控指标
var (
        requestCounter  metric.Int64Counter
        requestDuration metric.Float64Histogram
        errorCounter    metric.Int64Counter
)

// initMetrics 初始化监控指标
func initMetrics() error <span class="cov8" title="1">{
        meter := otel.GetMeterProvider().Meter("connect-go-example")

        var err error
        requestCounter, err = meter.Int64Counter(
                "http.server.request.count",
                metric.WithDescription("HTTP 请求总数"),
                metric.WithUnit("{request}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request counter: %w", err)
        }</span>

        <span class="cov8" title="1">requestDuration, err = meter.Float64Histogram(
                "http.server.request.duration",
                metric.WithDescription("HTTP 请求耗时"),
                metric.WithUnit("ms"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request duration histogram: %w", err)
        }</span>

        <span class="cov8" title="1">errorCounter, err = meter.Int64Counter(
                "http.server.error.count",
                metric.WithDescription("HTTP 错误总数"),
                metric.WithUnit("{error}"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create error counter: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MonitoringMiddleware 监控中间件
func MonitoringMiddleware(logger *zap.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        // 初始化指标
        if err := initMetrics(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize metrics", zap.Error(err))
        }</span>

        <span class="cov8" title="1">return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        startTime := time.Now()

                        // 获取 tracer
                        tracer := otel.GetTracerProvider().Tracer("connect-go-example")

                        // 创建 span
                        ctx, span := tracer.Start(r.Context(), fmt.Sprintf("%s %s", r.Method, r.URL.Path))
                        defer span.End()

                        // 设置 span 属性
                        span.SetAttributes(
                                attribute.String("http.method", r.Method),
                                attribute.String("http.route", r.URL.Path),
                                attribute.String("http.user_agent", r.UserAgent()),
                                attribute.String("http.host", r.Host),
                        )

                        // 包装 ResponseWriter 来捕获状态码
                        ww := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                        // 调用下一个处理器
                        next.ServeHTTP(ww, r.WithContext(ctx))

                        // 计算请求耗时
                        duration := float64(time.Since(startTime).Milliseconds())

                        // 记录指标
                        attributes := []attribute.KeyValue{
                                attribute.String("http.method", r.Method),
                                attribute.String("http.route", r.URL.Path),
                                attribute.Int("http.status_code", ww.statusCode),
                        }

                        // 记录请求计数
                        requestCounter.Add(ctx, 1, metric.WithAttributes(attributes...))

                        // 记录请求耗时
                        requestDuration.Record(ctx, duration, metric.WithAttributes(attributes...))

                        // 如果是错误响应，记录错误计数
                        if ww.statusCode &gt;= 400 </span><span class="cov8" title="1">{
                                errorCounter.Add(ctx, 1, metric.WithAttributes(attributes...))
                                span.SetStatus(codes.Error, http.StatusText(ww.statusCode))
                                span.SetAttributes(attribute.Int("http.status_code", ww.statusCode))
                                logger.Warn("HTTP request error",
                                        zap.String("method", r.Method),
                                        zap.String("path", r.URL.Path),
                                        zap.Int("status", ww.statusCode),
                                        zap.Duration("duration", time.Since(startTime)),
                                        zap.String("user_agent", r.UserAgent()),
                                )
                        }</span> else<span class="cov8" title="1"> {
                                span.SetStatus(codes.Ok, "OK")
                                span.SetAttributes(attribute.Int("http.status_code", ww.statusCode))
                                logger.Info("HTTP request completed",
                                        zap.String("method", r.Method),
                                        zap.String("path", r.URL.Path),
                                        zap.Int("status", ww.statusCode),
                                        zap.Duration("duration", time.Since(startTime)),
                                )
                        }</span>
                })
        }
}

// ConnectMonitoringInterceptor Connect 专用的监控拦截器
func ConnectMonitoringInterceptor(logger *zap.Logger) connect.UnaryInterceptorFunc <span class="cov8" title="1">{
        return func(next connect.UnaryFunc) connect.UnaryFunc </span><span class="cov8" title="1">{
                return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) </span><span class="cov8" title="1">{
                        startTime := time.Now()

                        // 获取 tracer
                        tracer := otel.GetTracerProvider().Tracer("connect-go-example")

                        // 创建 span
                        spanName := fmt.Sprintf("%s.%s", req.Spec().Procedure, req.Peer().Addr)
                        ctx, span := tracer.Start(ctx, spanName)
                        defer span.End()

                        // 设置 span 属性
                        span.SetAttributes(
                                attribute.String("rpc.system", "connect"),
                                attribute.String("rpc.service", req.Spec().Procedure),
                                attribute.String("rpc.method", req.Header().Get(":method")),
                                attribute.String("rpc.peer", req.Peer().Addr),
                        )

                        // 调用下一个拦截器
                        resp, err := next(ctx, req)

                        // 计算耗时
                        duration := float64(time.Since(startTime).Milliseconds())

                        // 记录指标
                        attributes := []attribute.KeyValue{
                                attribute.String("rpc.service", req.Spec().Procedure),
                                attribute.String("rpc.method", req.Header().Get(":method")),
                        }

                        // 记录 RPC 请求计数
                        requestCounter.Add(ctx, 1, metric.WithAttributes(attributes...))
                        requestDuration.Record(ctx, duration, metric.WithAttributes(attributes...))

                        if err != nil </span><span class="cov8" title="1">{
                                // 记录错误
                                errorCounter.Add(ctx, 1, metric.WithAttributes(attributes...))
                                span.SetStatus(codes.Error, err.Error())
                                logger.Error("RPC request failed",
                                        zap.String("service", req.Spec().Procedure),
                                        zap.String("method", req.Header().Get(":method")),
                                        zap.Duration("duration", time.Since(startTime)),
                                        zap.Error(err),
                                )
                        }</span> else<span class="cov8" title="1"> {
                                span.SetStatus(codes.Ok, "OK")
                                logger.Info("RPC request completed",
                                        zap.String("service", req.Spec().Procedure),
                                        zap.String("method", req.Header().Get(":method")),
                                        zap.Duration("duration", time.Since(startTime)),
                                )
                        }</span>

                        <span class="cov8" title="1">return resp, err</span>
                }
        }
}

// responseWriter 包装 http.ResponseWriter 来捕获状态码
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        written    bool
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        if !rw.written </span><span class="cov8" title="1">{
                rw.statusCode = code
                rw.written = true
                rw.ResponseWriter.WriteHeader(code)
        }</span>
}

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if !rw.written </span><span class="cov0" title="0">{
                rw.statusCode = http.StatusOK
                rw.written = true
        }</span>
        <span class="cov8" title="1">return rw.ResponseWriter.Write(b)</span>
}

// MiddlewareModule 提供 Fx 模块
var MiddlewareModule = fx.Module("server.middleware",
        fx.Provide(
                func(logger *zap.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
                        return MonitoringMiddleware(logger)
                }</span>,
                ConnectMonitoringInterceptor,
        ),
)
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "context"
        "net/http"
        "time"

        "connect-go-example/api/check/v1/checkv1connect"

        "connect-go-example/api/greet/v1/greetv1connect"
        conf "connect-go-example/internal/conf/v1"

        "connectrpc.com/connect"
        connectcors "connectrpc.com/cors"
        "connectrpc.com/otelconnect"
        "github.com/rs/cors"
        "go.uber.org/fx"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
        "golang.org/x/net/http2/h2c"
)

var Module = fx.Module("server",
        fx.Provide(
                NewHTTPServer,
        ),
)

func NewHTTPServer(
        lc fx.Lifecycle,
        cfg *conf.Bootstrap,
        greetv1Service greetv1connect.GreetServiceHandler,
        checkv1Service checkv1connect.CheckServiceHandler,
        logger *zap.Logger,
        monitoringMiddleware func(http.Handler) http.Handler,
        connectInterceptor connect.UnaryInterceptorFunc,
) *http.Server <span class="cov8" title="1">{
        // 1. 创建 OTel Connect 拦截器实例
        otelInterceptor, err := otelconnect.NewInterceptor(
                otelconnect.WithoutServerPeerAttributes(),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("failed to create otel interceptor", zap.Error(err))
        }</span>

        // 2. 将 OTel 拦截器和监控拦截器加入到 Connect 拦截器列表中
        <span class="cov8" title="1">interceptors := connect.WithInterceptors(otelInterceptor, connectInterceptor)

        // 3. 将拦截器传递给 Service Handler
        greetv1connectPath, greetv1connectHandler := greetv1connect.NewGreetServiceHandler(
                greetv1Service,
                interceptors,
        )
        checkv1connectPath, checkv1connectHandler := checkv1connect.NewCheckServiceHandler(
                checkv1Service,
                interceptors,
        )

        mux := http.NewServeMux()
        mux.Handle(greetv1connectPath, greetv1connectHandler)
        mux.Handle(checkv1connectPath, checkv1connectHandler)

        // CORS 配置
        corsHandler := cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   connectcors.AllowedMethods(),
                AllowedHeaders:   connectcors.AllowedHeaders(),
                ExposedHeaders:   connectcors.ExposedHeaders(),
                MaxAge:           7200,
                AllowCredentials: false,
        })

        // 创建处理器链：监控中间件 -&gt; CORS -&gt; HTTP/2
        handlerChain := monitoringMiddleware(corsHandler.Handler(mux))

        server := &amp;http.Server{
                Addr:         cfg.Server.Http.Addr,
                Handler:      h2c.NewHandler(handlerChain, &amp;http2.Server{}),
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
                IdleTimeout:  30 * time.Second,
        }

        // 注册生命周期钩子
        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        logger.Info("HTTP server starting", zap.String("addr", cfg.Server.Http.Addr))
                        return nil
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        logger.Info("HTTP server shutting down...")
                        return server.Shutdown(ctx)
                }</span>,
        })

        <span class="cov8" title="1">return server</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "context"

        v1 "connect-go-example/api/check/v1"
        "connect-go-example/api/check/v1/checkv1connect"
        "connect-go-example/internal/biz/model"

        "connectrpc.com/connect"
)

var _ checkv1connect.CheckServiceHandler = (*CheckService)(nil)

type CheckService struct {
        uc model.CheckUseCase
}

func NewCheckService(uc model.CheckUseCase) checkv1connect.CheckServiceHandler <span class="cov8" title="1">{
        return &amp;CheckService{
                uc: uc,
        }
}</span>

func (c *CheckService) Ready(ctx context.Context, _ *connect.Request[v1.ReadyCheckReq]) (*connect.Response[v1.ReadyCheckReply], error) <span class="cov8" title="1">{
        ready, err := c.uc.Ready(ctx, model.HealthCheckReq{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">reply := &amp;v1.ReadyCheckReply{
                Status:  ready.Status,
                Details: ready.Details,
        }
        return connect.NewResponse(reply), err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "context"

        v1 "connect-go-example/api/greet/v1"
        "connect-go-example/api/greet/v1/greetv1connect"
        "connect-go-example/internal/biz/model"

        "connectrpc.com/connect"
)

// GreetService 实现 Connect 服务
type GreetService struct {
        userUseCase model.UserUseCase
}

// 显式接口检查
var _ greetv1connect.GreetServiceHandler = (*GreetService)(nil)

func NewGreetService(userUseCase model.UserUseCase) greetv1connect.GreetServiceHandler <span class="cov8" title="1">{
        return &amp;GreetService{
                userUseCase: userUseCase,
        }
}</span>

func (s *GreetService) Register(ctx context.Context, req *connect.Request[v1.RegisterRequest]) (*connect.Response[v1.RegisterResponse], error) <span class="cov8" title="1">{
        userID, err := s.userUseCase.Register(
                ctx,
                req.Msg.Username,
                req.Msg.PasswordHash,
                req.Msg.Email,
                req.Msg.Salt,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response := &amp;v1.RegisterResponse{
                UserId: userID,
        }

        return connect.NewResponse(response), nil</span>
}

func (s *GreetService) GetAuthChallenge(ctx context.Context, req *connect.Request[v1.AuthChallengeRequest]) (*connect.Response[v1.AuthChallengeResponse], error) <span class="cov8" title="1">{
        challenge, err := s.userUseCase.GetAuthChallenge(ctx, req.Msg.Username)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeUnauthenticated, err)
        }</span>

        <span class="cov8" title="1">response := &amp;v1.AuthChallengeResponse{
                Challenge: challenge.Challenge,
                Salt:      challenge.Salt,
        }

        return connect.NewResponse(response), nil</span>
}

func (s *GreetService) SubmitAuth(ctx context.Context, req *connect.Request[v1.SubmitAuthRequest]) (*connect.Response[v1.SubmitAuthResponse], error) <span class="cov8" title="1">{
        result, err := s.userUseCase.SubmitAuth(
                ctx,
                req.Msg.Username,
                req.Msg.HashedCredential,
                req.Msg.AuthRequestId,
                req.Msg.ChallengeResponse,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeUnauthenticated, err)
        }</span>

        <span class="cov8" title="1">response := &amp;v1.SubmitAuthResponse{
                Code:      result.Code,
                State:     result.State,
                AuthToken: result.AuthToken,
        }

        return connect.NewResponse(response), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
